---
title: 后端开发面试知识点之redis
tags:
  - 后端开发
  - 面试
  - redis
catogories:
  - 后端开发
author: 艾逗笔
date: 2018-11-04 00:00:00
---




## 什么是Redis

- Redis是一种基于内存的高性能key-value数据库，可以每秒处理超过10万次读写操作。
- Redis支持丰富的数据类型，单个value存储的数据最大限制是1GB。
- Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，适合应用在较小数据量的高性能操作运算上。

## redis为什么这么快

- 完全基于内存，绝大部分请求是纯粹的内存操作，非常迅速
- 数据结构简单，对数据的操作也简单
- 采用单线程，避免了不必要的上下文切换和竞争条件，不存在加锁解锁操作，不会出现死锁而消耗性能
- 使用多路复用非阻塞IO模型
- 构建了自己的VM，在系统调用层面省去了请求开销

## 使用redis有哪些好处

- 速度快。redis数据是存在内存中的，查找和操作的时间复杂度都是O(1)
- 支持丰富的数据类型。string、list、hash、set、sortedSet
- 支持事务。可以保证操作的原子性
- 丰富的特性。可用于缓存数据、消息队列、设置过期时间等

## redis与memcached有哪些区别

- memcached只能存储简单的数据类型（字符串和二进制数据），redis支持更加丰富的数据类型
- redis的速度比memcached更快
- memcached数据全部存在内存中，断电后会挂掉，存储的数据不能超过内存大小。redis有部分数据存在硬盘上，支持数据的持久化
- redis是单线程的，memcached是单进程多线程的
- redis的key和value的大小限制都是512M，memcached的key最大为250字节，value最大为1M

## redis应用场景

- 会话缓存
- 全页缓存
- 消息队列
- 排行榜/计数器
- 发布订阅

## redis的持久化方式aof与rdb的比较

- rdb在不同的时间点，对redis存储的数据生成快照并写入磁盘；aof将redis执行的写操作命令追加到文件，恢复数据的时候将记录的命令执行一遍
- rdb与aof两种持久化方式可以同时使用，数据恢复时优先使用aof文件进行恢复
- aof生成的文件要比rdb生成的大，恢复数据时，aof方式要比rdb慢
- aof方式恢复数据完整性比rdb高
- rdb通过save和bgsave命令来控制数据备份，aof支持重写方式优化aof文件过大的问题

## redis事务控制

- ACID特性
- MULTI/EXEC/DISCARD/WATCH命令

## pipeline与multi的区别

- pipeline使用客户端缓冲；multi使用服务端缓冲
- multi每一条命令都需要发送一次服务端请求；pipeline使用exec最后一次性发送给服务端
- multi可以保证数据操作的原子性；pipeline无法保证原子性

## redis主从复制

- 当一个从数据库启动时，会向主数据库发送sync命令
- 主数据库接收到sync命令后会开始在后台执行rdb保存快照操作，并在快照保存期间缓存接收到的命令
- 快照保存完成后，主数据库将快照文件和缓存的命令一起发送给从数据库
- 从数据库根据接收到的快照文件和缓存命令载入数据

## redis高可用方案：哨兵模式（sentinel）

- 监控：sentinel实时监控主数据库和从数据库的状态，并实现自动切换
- 提醒：当监控的某个redis服务器出现问题时候，sentinel可以给系统管理员发送通知
- 自动故障转移：当一个主服务器不能正常工作时候，sentinel将一个从服务器提升为从服务器

## redis集群：Cluster

- 三主三从
- hash槽点（16348）

## redis数据淘汰策略

- volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
- allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集中任意选择数据淘汰
- no-enviction（驱逐）：禁止驱逐数据

## redis过期删除策略

- 定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间达到时，立即删除键。这种方式对内存友好，但是浪费CPU资源
- 惰性删除：获取键的时候，判断键是否过期，如果过期则删除、这种方式对CPU友好，但是浪费内存
- 定期删除：每隔一段时间，就对数据做一次扫描，从每个数据库中随机选择部分过期的键进行删除。

## redis数据丢失

- 程序bug或人为误操作引起的，比如执行flushdb之类的命令
- 缓存区内存不足触发数据自动淘汰策略；可以合理调大maxmemory
- 主从同步故障重启后导致的数据丢失
- 网络分区环境下可能导致数据短时间内写入丢失
- 主从复制数据不一致切换后导致的数据丢失
- 大量过期键被删除，让业务方以为数据丢失

## redis常见性能问题和解决方案

- master最好不要做任何持久化方式，如rbd快照和aof日志文件
- 如果需要持久化数据，可以在slave开启aof数据备份，设置每秒同步一次
- 为了主从复制的稳定性，master和slave最好在同一个局域网内
- 尽量避免在压力很大的主库上增加从库
- 主从复制不要用图状结构，改用单向链表结构

## redis有序集合的实现方式

- 压缩列表：ziplist
- 跳跃表：skiplist

## redis键冲突

- 开放地址法
- 链地址法
- rehash

## 提高缓存命中率的方式

- 设置尽可能小的缓存粒度
- 调整缓存过期自动回收策略
- 增加存储容量
- 缓存预加载（预热）

## 使用redis实现分布式锁

- setnx
```
SETNX lock.foo <current Unix time + lock timeout + 1>
```
- getset
```
GETSET lock.foo <current Unix timestamp + lock timeout + 1>
```

## 缓存雪崩/缓存穿透/缓存预热/缓存更新/缓存降级

- 缓存雪崩：设置的缓存在同一时间失效，导致大量请求直接读写数据库，造成数据库压力；解决办法有使用锁或队列控制数据库的并发读写、设置过期标识更新缓存、为缓存设置不同的过期时间等。
- 缓存穿透：在数据库中不存在的数据，每次都需要在缓存和数据库中分别查询。解决办法：使用布隆过滤器，对空数据也进行缓存，使用一个缓存区域存储空值等。
- 缓存预热：将需要缓存的数据手动刷新进缓存中。方案：写个刷新页面上线的时候操作下，定时刷新缓存
- 缓存更新：自定义缓存淘汰策略。方案：定时清理过期的缓存，用户请求过来时候判断缓存过期
- 缓存降级：对一些非关键数据做开关、设置人工降级策略
